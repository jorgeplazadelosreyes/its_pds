<!DOCTYPE html>
<html>
  <head>
    <script src="https://unpkg.com/konva@8.3.12/konva.min.js"></script>
    <meta charset="utf-8" />
    <title>Estatica</title>
    <h2 style="margin_down:20; outline: black solid; text-align:center">Aca saldra un enunciado </h2>
    <style>
      body {
        margin_top: 20;
        margin_left: 20;
        padding: 0;
        overflow: hidden;
        background-color: #F5F5F5;
        background-size: cover;
        outline: black solid
      }

      #desc {
        position : absolute;
        top: 5px;
        left: 5px;
      }
    </style>
  </head>
  <body>
    <div id="container", style="width: 1500px; height: 500px;"></div>
    <script>
      var width = 1500;
      var height = 500;
      var shadowOffset = 20;
      var tween = null;
      var blockSnapSize = 30;

      var shadowRectangle = new Konva.Rect({
        x: 0,
        y: 0,
        width: blockSnapSize,
        height: blockSnapSize,
        fill: '#FF7B17',
        opacity: 0.6,
        stroke: '#CF6412',
        strokeWidth: 3,
        dash: [20, 2]
      });

      function newRectangle(x, y, layer, stage) {
        let rectangle = new Konva.Rect({
          x: x,
          y: y,
          width: blockSnapSize ,
          height: blockSnapSize ,
          fill: '#fff',
          stroke: '#ddd',
          strokeWidth: 1,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true
        });
        rectangle.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          rectangle.moveToTop();
        });
        rectangle.on('dragend', (e) => {
          rectangle.position({
            x: Math.round(rectangle.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(rectangle.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        rectangle.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(rectangle.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(rectangle.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });
        layer.add(rectangle);
      }

      function newArrow(x, y, layer, stage, tilt) {
        var arrow = new Konva.Arrow({
          x: x,
          y: y,
          points: [0, 0, 20, 10],
          pointerLength: 2,
          pointerWidth: 2,
          rotation: tilt,
          fill: 'black',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true
        });

        arrow.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          arrow.moveToTop();
        });
        arrow.on('dragend', (e) => {
          arrow.position({
            x: (Math.round(arrow.x() / blockSnapSize) * blockSnapSize) + 10,
            y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        arrow.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });

        var tr2 = new Konva.Transformer({
          nodes: [arrow],
          centeredScaling: false,
        });
        layer.add(tr2);
        layer.add(arrow);

      }



      function toolBar(layer, stage) {
        let rectangle = new Konva.Rect({
          x: 1400,
          y: 10,
          width: blockSnapSize ,
          height: blockSnapSize,
          fill: '#fff',
          stroke: '#ddd',
          strokeWidth: 1,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        rectangle.on('pointerdown', function () {
          newRectangle(blockSnapSize * 17, blockSnapSize * 3, layer, stage);
        });

        let arrowVert = new Konva.Arrow({
          x: 1400,
          y: 50,
          points: [0, 0, 20, 10],
          pointerLength: 2,
          pointerWidth: 2,
          rotation: 60,
          fill: 'black',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        arrowVert.on('pointerdown', function () {
          newArrow(blockSnapSize * 17, blockSnapSize * 3, layer, stage, 60);
        });

        let arrowHor = new Konva.Arrow({
          x: 1415,
          y: 60,
          points: [0, 0, 20, 10],
          pointerLength: 2,
          pointerWidth: 2,
          rotation: -25,
          fill: 'black',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        arrowHor.on('pointerdown', function () {
          newArrow(blockSnapSize * 17, blockSnapSize * 3, layer, stage, -25);
        });
        
        let arrowDiag = new Konva.Arrow({
          x: 1450,
          y: 55,
          points: [0, 0, 20, 10],
          pointerLength: 2,
          pointerWidth: 2,
          rotation: 15,
          fill: 'black',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        arrowDiag.on('pointerdown', function () {
          newArrow(blockSnapSize * 17, blockSnapSize * 3, layer, stage, 15);
        });
        
        layer.add(rectangle);
        layer.add(arrowVert);
        layer.add(arrowHor);
        layer.add(arrowDiag);

      }

      var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
      });

      var gridLayer = new Konva.Layer();
      var padding = blockSnapSize;
      console.log(width, padding, width / padding);
      for (var i = 0; i < width / padding; i++) {
        gridLayer.add(new Konva.Line({
          points: [Math.round(i * padding) + 0.5, 0, Math.round(i * padding) + 0.5, height],
          stroke: '#ddd',
          strokeWidth: 1,
        }));
      }

      gridLayer.add(new Konva.Line({points: [0,0,10,10]}));
      for (var j = 0; j < height / padding; j++) {
        gridLayer.add(new Konva.Line({
          points: [0, Math.round(j * padding), width, Math.round(j * padding)],
          stroke: '#ddd',
          strokeWidth: 0.5,
        }));
      }

      var layer = new Konva.Layer();
      shadowRectangle.hide();
      layer.add(shadowRectangle);

      toolBar( layer, stage);

      stage.add(gridLayer);
      stage.add(layer);

    </script>
  </body>
</html>

/*
      function newEmpotrado(x, y, layer, stage) {
        var empotrado= new Konva.Group({
          x: x,
          y: y,

          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true
        });

        var empotrado1 = new Konva.Line({
          points: [15, 0, 15, 25],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });

        var empotrado2 = new Konva.Line({
          points: [0, 0, 30, 0],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });
        empotrado.add(empotrado1);
        empotrado.add(empotrado2);

        empotrado.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          empotrado.moveToTop();
        });
        empotrado.on('dragend', (e) => {
          empotrado.position({
            x: Math.round(empotrado.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(empotrado.y() / blockSnapSize) * blockSnapSize + 30
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        empotrado.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(empotrado.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(empotrado.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });
        layer.add(empotrado);
      }
      */

      /*
      var empotrado = new Konva.Group({
        x: 1420,
        y: 150,
      });

      var empotrado1 = new Konva.Line({
        points: [15, 0, 15, -25],
        stroke: 'red',
        strokeWidth: 4,
        lineCap: 'round',
        lineJoin: 'round',
        
      });


      var empotrado2 = new Konva.Line({
        points: [0, 0, 30, 0],
        stroke: 'red',
        strokeWidth: 4,
        lineCap: 'round',
        lineJoin: 'round',
        
      });

      empotrado.add(empotrado1);
      empotrado.add(empotrado2);

      empotrado.on('pointerdown', function () {
        newEmpotrado(blockSnapSize * 17, blockSnapSize * 3, layer, stage);
      });
      */