<!DOCTYPE html>
<html>
	<head>
		<script src="https://unpkg.com/konva@8.3.12/konva.min.js"></script>
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		
		<meta charset="utf-8" />
		<title>Editar DCL</title>
		<h2 style="margin_down:20; outline: black solid; text-align:center">Aca saldra un enunciado </h2>
		<style>
			body {
				margin_top: 20;
				margin_left: 20;
				overflow: hidden;
				background-color: #f0f0f0;
				outline: black solid
			}
		</style>
  	</head>
  	<body>
		<h6 id="homework-details" data-homework-id="{{ homework.id }}" data-homework-diagram = "{{ homework.diagram }}"></h6>
    
		<div id="container"></div>
		<script>
			var alto = window.innerHeight - 200;
			var largo = window.innerWidth - 30;
			var shadowOffset = 20;
			var tween = null;
			var blockSnapSize = 30;

			var shadowRectangle = new Konva.Rect({
				x: 0,
				y: 0,
				width: blockSnapSize,
				height: blockSnapSize,
				fill: '#FF7B17',
				opacity: 0.6,
				stroke: '#CF6412',
				strokeWidth: 3,
				dash: [20, 2]
			});
      
			data = $("#homework-details").data("homeworkDiagram")

			//var stage = Konva.Node.create(data, "container")

      function loadForm(json){
        /*
        layer.find('Line').destroy();
        layer.find('Circle').destroy();
        layer.find('Arrow').destroy();
        layer.draw();
        */
        console.log("equis de");
        
        console.log(layer)
        
        console.log(json)
        objects=json["children"][0]["children"]
        console.log(objects["length"])
        
        for (var i = 0; i<objects["length"]; i++){
          console.log(objects[i]["className"]);
          
          //console.log(objects[i]["attrs"]["name"]);

          if(objects[i]["className"]=="Rect"){
            if(objects[i]["attrs"]["name"]=='barra'){
                item=objects[i]
                
                newBarra(item["attrs"]["x"], item["attrs"]["y"], layer, stage)
                
              }
        }
          
          if(objects[i]["className"]=="Arc"){

            var str = objects[i]["attrs"]["name"]


            console.log("this moment: ",  str)

            if(objects[i]["attrs"]["name"]=='momento'){
                item=objects[i]
                console.log("obj: ",item);
                console.log(item["attrs"]["x"], item["attrs"]["y"])
                newMomento(item["attrs"]["x"], item["attrs"]["y"], item["attrs"]["rotation"], layer, stage)
                
              }
          }
          if(objects[i]["className"]=="Arrow"){
            if(objects[i]["attrs"]["name"]=='arrow'){
                item=objects[i]
                newArrow(item["attrs"]["x"], item["attrs"]["y"], item["attrs"]["rotation"], layer, stage)
            }
          }
          if(objects[i]["className"]=="RegularPolygon"){
            if(objects[i]["attrs"]["name"]=='fijo'){
                item=objects[i]
                newFijo(item["attrs"]["x"], item["attrs"]["y"], item["attrs"]["rotation"], layer, stage)
            }
          }
          if(objects[i]["className"]=="Group"){
            if(objects[i]["attrs"]["name"]=='deslizante'){
                item=objects[i]
                newDeslizante(item["attrs"]["x"], item["attrs"]["y"], item["attrs"]["rotation"], layer, stage)
            }
            else if(objects[i]["attrs"]["name"]=='empotrado'){
              item=objects[i]
              newEmpotrado(item["attrs"]["x"], item["attrs"]["y"], item["attrs"]["rotation"], layer, stage) 
            }
          }
          if(objects[i]["className"]=="Circle" || objects[i]["className"]=="Line"){
            if(objects[i]["attrs"]["name"]=='rotula'){
              item=objects[i]
              newRotula(item["attrs"]["x"], item["attrs"]["y"], layer, stage) 
            }
            else if(objects[i]["attrs"]["name"]=='biela1'){
              item=objects[i]
              x1 = item["attrs"]["x"]
              y1 = item["attrs"]["y"]

              if(typeof(x1) != "undefined" && typeof(x2) != "undefined" && typeof(y1) != "undefined" && typeof(y2)){
                newBiela( x1, y1, x2, y2, layer, stage)
              }
            }
            else if(objects[i]["attrs"]["name"]=='biela2'){
              item=objects[i]
              x2 = item["attrs"]["x"]
              y2 = item["attrs"]["y"]
              if(typeof(x1) != "undefined" && typeof(x2) != "undefined" && typeof(y1) != "undefined" && typeof(y2)){
                newBiela( x1, y1, x2, y2, layer, stage)
              }
            }
          }
        }   
      }

      console.log("data entrandte:");
      console.log(data["children"][0]["children"]);
      console.log("fin");

      const stage = new Konva.Stage({
          container: 'container',
          width: largo,
          height: alto
        });
		
      
			var layer = new Konva.Layer();
				
			var padding = 30;
			for (var i = 0; i < (largo / padding) - 2; i++) {
				layer.add(new Konva.Line({
					points: [Math.round(i * padding) + 0.5, 0, Math.round(i * padding) + 0.5, alto],
					stroke: '#000000',
					strokeWidth: 1,
				}));
			}
			layer.add(new Konva.Line({points: [0,0,10,10]}));
      
			for (var j = 0; j < (largo / padding); j++) {
				layer.add(new Konva.Line({
					points: [0, Math.round(j * padding), largo - 85, Math.round(j * padding)],
					stroke: '#000000',
					strokeWidth: 0.5,
				}));
			}

			function newArrow(x, y, rotation, layer, stage) {
				var arrow = new Konva.Arrow({
					x: x,
					y: y,
					points: [0, 0, 75, 0],
					pointerLength: 2,
					pointerWidth: 2,
					fill: 'black',
					stroke: 'black',
					strokeWidth: 4,
					shadowColor: 'black',
					shadowBlur: 2,
					shadowOffset: {x : 1, y : 1},
					shadowOpacity: 0.4,
					draggable: true,
					rotation: 0,
          name: "arrow",
          rotation: rotation,
				});

				arrow.on('dragstart', (e) => {
					shadowRectangle.show();
					shadowRectangle.moveToTop();
					arrow.moveToTop();
				});
        
				arrow.on('dragend', (e) => {
          console.log("rotation: ", arrow.rotation())

          if(arrow.rotation() == 0){
            arrow.position({
              x: Math.round((arrow.x() ) / blockSnapSize) * blockSnapSize  ,
              y: Math.round((arrow.y() ) / blockSnapSize) * blockSnapSize + 15
            });
          }
          else if(Math.round(arrow.rotation()) == 45){
            arrow.position({
              x: Math.round((arrow.x() + 15) / blockSnapSize) * blockSnapSize ,
              y: Math.round((arrow.y() + 15) / blockSnapSize) * blockSnapSize 
            });
          }
          else if(Math.round(arrow.rotation()) == 90){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize + 15,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 0
            });
          }
          else if(Math.round(arrow.rotation()) == 135){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize + 0,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 0
            });
          }
          else if(Math.round(arrow.rotation()) == 180){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize + 0,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 15
            });
          }
          else if(Math.round(arrow.rotation()) == -135){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize - 20,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 10
            });
          }
          else if(Math.round(arrow.rotation()) == -90){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize + 15,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 0
            });
          }
          else if(Math.round(arrow.rotation()) == -45){
            arrow.position({
              x: Math.round(arrow.x() / blockSnapSize) * blockSnapSize + 0,
              y: Math.round(arrow.y() / blockSnapSize) * blockSnapSize + 0
            });
          }
				stage.batchDraw();
				shadowRectangle.hide();
				});
				arrow.on('dragmove', (e) => {
          if(arrow.rotation() == 0){
            shadowRectangle.position({
              x: Math.round((arrow.x() + 60) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() ) / blockSnapSize) * blockSnapSize
            });
          }

          else if(Math.round(arrow.rotation()) == 90){
            shadowRectangle.position({
              x: Math.round((arrow.x() + 0) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() + 60) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(arrow.rotation()) == 135){
            shadowRectangle.position({
              x: Math.round((arrow.x() - 60) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() + 30) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(arrow.rotation()) == 180){
            shadowRectangle.position({
              x: Math.round((arrow.x() - 90) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() + 0) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(arrow.rotation()) == -135){
            shadowRectangle.position({
              x: Math.round((arrow.x() - 90) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() - 60) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(arrow.rotation()) == -90){
            shadowRectangle.position({
              x: Math.round((arrow.x() - 0) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() - 90) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(arrow.rotation()) == -45){
            shadowRectangle.position({
              x: Math.round((arrow.x() + 30) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() - 60) / blockSnapSize) * blockSnapSize
            });
          }


          else {
            shadowRectangle.position({
              x: Math.round((arrow.x() + 45) / blockSnapSize) * blockSnapSize,
              y: Math.round((arrow.y() + 45) / blockSnapSize) * blockSnapSize
            });
          }
				
				stage.batchDraw();
				});

				var tr = new Konva.Transformer({
					nodes: [arrow],
					centeredScaling: false,
					resizeEnabled: false,
					rotation: 0,
          rotationSnaps: [0, 45, 90, 135, 180, 225, 270, 315, 360],
          rotationSnapTolerance: 22.5,
				});
				layer.add(tr);
        
        layer.add(arrow);
        stage.on('click tap', function (e) {
          if (e.target === arrow) {
            tr.nodes([arrow]);
          }
          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          const metaPressed = e.evt.ctrlKey;
          const isSelected = tr.nodes().indexOf(e.target) >= 0;

          if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            tr.nodes([]);
            const nodes = e.target.destroy(); // use slice to have new copy of array
            // remove node from array
          }
        });

      }

      function newFijo(x, y, rotation, layer, stage) {
        let fijo = new Konva.RegularPolygon({
          x: x,
          y: y,
          sides: 3,
          radius: 15,
          fill: 'grey',
          stroke: 'black',
          strokeWidth: 2,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "fijo",
          rotation: rotation,
        });
        fijo.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          fijo.moveToTop();
        });
        fijo.on('dragend', (e) => {

          console.log("rotation: ", fijo.rotation())

          if(fijo.rotation() == 0){
            fijo.position({
              x: Math.round(fijo.x() / blockSnapSize) * blockSnapSize +15,
              y: Math.round(fijo.y() / blockSnapSize) * blockSnapSize + 15
            });
          }
          else if(fijo.rotation() == 90){
            fijo.position({
              x: Math.round(fijo.x() / blockSnapSize) * blockSnapSize +15,
              y: Math.round(fijo.y() / blockSnapSize) * blockSnapSize + 15
            });
          }
          else if(fijo.rotation() == 180){
            fijo.position({
              x: Math.round(fijo.x() / blockSnapSize) * blockSnapSize +15,
              y: Math.round(fijo.y() / blockSnapSize) * blockSnapSize + 15
            });
          }
          else if(Math.round(fijo.rotation()) == -90){
            fijo.position({
              x: Math.round(fijo.x() / blockSnapSize) * blockSnapSize +15,
              y: Math.round(fijo.y() / blockSnapSize) * blockSnapSize + 15
            });
          }
          stage.batchDraw();
          shadowRectangle.hide();
        });
        fijo.on('dragmove', (e) => {
          
          shadowRectangle.position({
            x: Math.round(fijo.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(fijo.y() / blockSnapSize) * blockSnapSize
          });
          
          stage.batchDraw();
        });

        var tr = new Konva.Transformer({
          nodes: [fijo],
          centeredScaling: false,
          resizeEnabled: false,
          rotationSnaps: [0, 90, 180, 270],
          rotationSnapTolerance: 45,
        });
        layer.add(tr);
        layer.add(fijo);
        stage.on('click tap', function (e) {
          if (e.target === fijo) {
            tr.nodes([fijo]);
          }
          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          const metaPressed = e.evt.ctrlKey;
          const isSelected = tr.nodes().indexOf(e.target) >= 0;

          if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            tr.nodes([]);
            const nodes = e.target.destroy(); // use slice to have new copy of array
            // remove node from array
          }
        });
      }

      function newDeslizante(x, y, rotation, layer, stage, count) {
        var deslizante = new Konva.Group({
          x: x,
          y: y,

          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "deslizante",
          rotation: rotation,
        });

        var deslizanteT = new Konva.RegularPolygon({
          x: 15,
          y: -13,
          sides: 3,
          radius: 15,
          fill: 'gray',
          stroke: 'black',
          strokeWidth: 2,
        });

        var deslizanteL = new Konva.Line({
          points: [0, 0, 30, 0],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
         
        });
        deslizante.add(deslizanteT);
        deslizante.add(deslizanteL);

        deslizante.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          deslizante.moveToTop();
        });
        deslizante.on('dragend', (e) => {

          
          deslizante.position({
            x: Math.round(deslizante.x() / blockSnapSize) * blockSnapSize ,
            y: Math.round(deslizante.y() / blockSnapSize) * blockSnapSize 
          });
          
          stage.batchDraw();
          shadowRectangle.hide();
        });
        deslizante.on('dragmove', (e) => {
          console.log(deslizante.rotation())
          if(Math.round(deslizante.rotation()) == 0){
            shadowRectangle.position({
              x: Math.round(deslizante.x() / blockSnapSize) * blockSnapSize,
              y: Math.round((deslizante.y() -30) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(deslizante.rotation()) == 90){
            shadowRectangle.position({
              x: Math.round(deslizante.x() / blockSnapSize) * blockSnapSize,
              y: Math.round((deslizante.y()) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(deslizante.rotation()) == 180){
            shadowRectangle.position({
              x: Math.round((deslizante.x() - 30) / blockSnapSize) * blockSnapSize,
              y: Math.round((deslizante.y()) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(deslizante.rotation()) == -90){
            shadowRectangle.position({
              x: Math.round((deslizante.x() - 30) / blockSnapSize) * blockSnapSize,
              y: Math.round((deslizante.y() - 30) / blockSnapSize) * blockSnapSize
            });
          }
          stage.batchDraw();
        });
        var tr = new Konva.Transformer({
          nodes: [deslizante],
          centeredScaling: false,
          resizeEnabled: false,
          rotationSnaps: [0, 90, 180, 270],
          rotationSnapTolerance: 45,
        });
        layer.add(tr);
        layer.add(deslizante);
        stage.on('click tap', function (e) {
          if (e.target === deslizanteT) {
            tr.nodes([deslizante]);
          }
          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          const metaPressed = e.evt.ctrlKey;
          const isSelected = tr.nodes().indexOf(e.target) >= 0;

          if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            tr.nodes([]);
            const nodes = e.target.destroy(); // use slice to have new copy of array
            // remove node from array
          }
        });
      }

      function newEmpotrado(x, y, rotation, layer, stage, count) {
        var empotrado= new Konva.Group({
          x: x,
          y: y,

          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "empotrado",
          rotation: rotation,
        });

        var empotrado1 = new Konva.Line({
          points: [15, 0, 15, -25],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });

        var empotrado2 = new Konva.Line({
          points: [0, 0, 30, 0],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });
        empotrado.add(empotrado1);
        empotrado.add(empotrado2);

        empotrado.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          empotrado.moveToTop();
        });
        empotrado.on('dragend', (e) => {
          
          empotrado.position({
            x: Math.round(empotrado.x() / blockSnapSize) * blockSnapSize ,
            y: Math.round(empotrado.y() / blockSnapSize) * blockSnapSize 
          });
          
          stage.batchDraw();
          shadowRectangle.hide();
        });
        empotrado.on('dragmove', (e) => {
          if(Math.round(empotrado.rotation()) == 0){
            shadowRectangle.position({
              x: Math.round((empotrado.x()) / blockSnapSize) * blockSnapSize,
              y: Math.round((empotrado.y() - 30) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(empotrado.rotation()) == 90){
            shadowRectangle.position({
              x: Math.round((empotrado.x()) / blockSnapSize) * blockSnapSize,
              y: Math.round((empotrado.y()) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(empotrado.rotation()) == 180){
            shadowRectangle.position({
              x: Math.round((empotrado.x() - 30) / blockSnapSize) * blockSnapSize,
              y: Math.round((empotrado.y()) / blockSnapSize) * blockSnapSize
            });
          }
          else if(Math.round(empotrado.rotation()) == -90){
            shadowRectangle.position({
              x: Math.round((empotrado.x() - 30) / blockSnapSize) * blockSnapSize,
              y: Math.round((empotrado.y() - 30) / blockSnapSize) * blockSnapSize
            });
          }
          stage.batchDraw();
        });
        var tr = new Konva.Transformer({
          nodes: [empotrado],
          centeredScaling: false,
          resizeEnabled: false,
          rotationSnaps: [0, 90, 180, 270],
          rotationSnapTolerance: 45,
        
        });
        layer.add(tr);
        layer.add(empotrado);
        stage.on('click tap', function (e) {
          if (e.target === empotrado1 || e.target === empotrado2) {
            tr.nodes([empotrado]);
          }
          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          const metaPressed = e.evt.ctrlKey;
          const isSelected = tr.nodes().indexOf(e.target) >= 0;

          if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            tr.nodes([]);
            const nodes = e.target.destroy(); // use slice to have new copy of array
            // remove node from array
          }
        });
      }

      function newRotula(x, y, layer, stage, count) {

        var rotula = new Konva.Circle({
          x: x,
          y: y,
          radius: 15,
          fill: 'red',
          stroke: 'black',
          strokeWidth: 2,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "rotula",
        });

        rotula.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          rotula.moveToTop();
        });
        rotula.on('dragend', (e) => {
          rotula.position({
            x: Math.round(rotula.x() / blockSnapSize) * blockSnapSize + 15,
            y: Math.round(rotula.y() / blockSnapSize) * blockSnapSize + 15
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        rotula.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(rotula.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(rotula.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });
        layer.add(rotula);
        
      }
      function newBiela(x1, y1, x2=x1+30, y2=y1, layer, stage, count) {

        var b1 = new Konva.Circle({
          x: x1,
          y: y1,
          radius: 15,
          fill: 'green',
          stroke: 'black',
          strokeWidth: 2,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x1 : 1, y1 : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "biela1"
        });

        var b2 = new Konva.Circle({
          x: x2,
          y: y2,
          radius: 15,
          fill: 'green',
          stroke: 'black',
          strokeWidth: 2,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x2 : 1, y2 : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "biela2"
        });

        const line = new Konva.Line({
          points: [x1,y1,x2,y2],
          stroke: 'green',
          name: "bielaL"
        });

        b1.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          b1.moveToTop();
        });
        b1.on('dragend', (e) => {
          b1.position({
            x: Math.round(b1.x() / blockSnapSize) * blockSnapSize +15,
            y: Math.round(b1.y() / blockSnapSize) * blockSnapSize +15
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        b1.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(b1.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(b1.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });

        b2.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          b2.moveToTop();
        });
        b2.on('dragend', (e) => {
          b2.position({
            x: Math.round(b2.x() / blockSnapSize) * blockSnapSize +15,
            y: Math.round(b2.y() / blockSnapSize) * blockSnapSize +15
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        b2.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(b2.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(b2.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });

        function updateLine() {
          const points = [
            b1.x(),
            b1.y(),
            b2.x(),
            b2.y(),
          ]
          line.points(points);
          layer.batchDraw();
        }

        function updateLineEnd() {
          const points = [
            Math.round(b1.x() / blockSnapSize) * blockSnapSize,
            Math.round(b1.y() / blockSnapSize) * blockSnapSize,
            Math.round(b2.x() / blockSnapSize) * blockSnapSize,
            Math.round(b2.y() / blockSnapSize) * blockSnapSize
          ]
          line.points(points);
          layer.batchDraw();
        }

        b1.on('dragmove', updateLine);
        b2.on('dragmove', updateLine);

        b1.on('dragend', updateLine);
        b2.on('dragend', updateLine);
        
        console.log("LINEA")
        console.log(line)
        layer.add(line);
        layer.add(b1);
        layer.add(b2);
      }

      function newBarra(x, y, layer, stage) {
        var barra = new Konva.Rect({
          x: x,
          y: y,
          width: 30,
          height: 30,
          fill: 'gray',
          stroke: 'black',
          strokeWidth: 1,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "barra",
        });

        barra.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          barra.moveToTop();
        });
        barra.on('dragend', (e) => {
          barra.position({
            x: Math.round(barra.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(barra.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        barra.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(barra.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(barra.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });

        layer.add(barra);
        
      }
    
      function newMomento(x, y, rotation, layer, stage, count) {
        
        let momento = new Konva.Arc({
          x: x,
          y: y,
          innerRadius: 10,
          outerRadius: 20,
          angle: 180,
          fill: 'yellow',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: true,
          name: "momento_" + count.toString(),
          rotation: rotation,
        });
        momento.on('dragstart', (e) => {
          shadowRectangle.show();
          shadowRectangle.moveToTop();
          momento.moveToTop();
        });
        momento.on('dragend', (e) => {
          momento.position({
            x: Math.round(momento.x() / blockSnapSize) * blockSnapSize + 15,
            y: Math.round(momento.y() / blockSnapSize) * blockSnapSize +7.5
          });
          stage.batchDraw();
          shadowRectangle.hide();
        });
        momento.on('dragmove', (e) => {
          shadowRectangle.position({
            x: Math.round(momento.x() / blockSnapSize) * blockSnapSize,
            y: Math.round(momento.y() / blockSnapSize) * blockSnapSize
          });
          stage.batchDraw();
        });

        var tr = new Konva.Transformer({
          nodes: [momento],
          centeredScaling: false,
          resizeEnabled: false,
        });
        layer.add(tr);
        layer.add(momento);
        stage.on('click tap', function (e) {
          if (e.target === momento) {
            tr.nodes([momento]);
          }
          // if click on empty area - remove all selections
          if (e.target === stage) {
            tr.nodes([]);
            return;
          }

          const metaPressed = e.evt.ctrlKey;
          const isSelected = tr.nodes().indexOf(e.target) >= 0;

          if (metaPressed && isSelected) {
            // if we pressed keys and node was selected
            // we need to remove it from selection:
            tr.nodes([]);
            const nodes = e.target.destroy(); // use slice to have new copy of array
            // remove node from array
          }
        });
      }
      
      function toolBar(layer, stage, counter) {
        // PRETTY
        var separadorTool = new Konva.Line({
          points: [largo - 85, 0, largo - 85, 600],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });
        layer.add(separadorTool)
        
        // ARROW
        let arrow = new Konva.Arrow({
          x: largo - 37.5,
          y: 35,
          points: [0, 0, 20, 10],
          pointerLength: 2,
          pointerWidth: 2,
          rotation: 62,
          fill: 'black',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        arrow.on('pointerdown', function () {
          counter[0] = counter[0] + 1
          newArrow(blockSnapSize * 17, blockSnapSize * 3, rotation = 0, layer, stage, 62, 15, 0, counter[0]);
          //let json = stage.toJSON();
          //console.log(JSON.parse(json)["children"][0]["children"])
        });

        var arrowText = new Konva.Text({
          x: largo - 52,
          y: 65,
          text: 'Fuerza',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(arrowText);
        // ARROW
        // FIJO
        var fijo = new Konva.RegularPolygon({
          x: largo - 35,
          y: 110,
          sides: 3,
          radius: 15,
          fill: 'gray',
          stroke: 'black',
          strokeWidth: 2,
        });
        fijo.on('pointerdown', function () {
          counter[1] = counter[1] + 1
          newFijo(blockSnapSize * 17, blockSnapSize * 3, rotation = 0, layer, stage, counter[1]);
        });

        var fijoText = new Konva.Text({
          x: largo - 43,
          y: 125,
          text: 'Fijo',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(fijoText);
        // FIJO
        // DESLIZANTE
        var deslizante = new Konva.Group({
          x: largo - 50,
          y: 180,
        });

        var deslizanteT = new Konva.RegularPolygon({
          x: 15,
          y: -10,
          sides: 3,
          radius: 15,
          fill: 'gray',
          stroke: 'black',
          strokeWidth: 2,
        });

        var deslizanteL = new Konva.Line({
          points: [0, 0, 30, 0],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });

        deslizante.add(deslizanteT);
        deslizante.add(deslizanteL);

        deslizante.on('pointerdown', function () {
          counter[2] = counter[2] + 1
          newDeslizante(blockSnapSize * 17, blockSnapSize * 3, rotation = 0, layer, stage, counter[2]);
        });
        var deslizanteText = new Konva.Text({
          x: largo - 60,
          y: 185,
          text: 'Deslizante',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(deslizanteText);
        // DESLIZANTE
        // EMPOTRADO
        var empotrado = new Konva.Group({
          x: largo - 50,
          y: 240,
        });

        var empotrado1 = new Konva.Line({
          points: [15, 0, 15, -25],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });

        var empotrado2 = new Konva.Line({
          points: [0, 0, 30, 0],
          stroke: 'red',
          strokeWidth: 4,
          lineCap: 'round',
          lineJoin: 'round',
          
        });

        empotrado.add(empotrado1);
        empotrado.add(empotrado2);

        empotrado.on('pointerdown', function () {
          counter[3] = counter[3] + 1
          newEmpotrado(blockSnapSize * 17, blockSnapSize * 3, rotation = 0, layer, stage, counter[3]);
        });
        var empotradoText = new Konva.Text({
          x: largo - 80,
          y: 245,
          text: 'Empotramiento',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(empotradoText);
        // EMPOTRADO
        // ROTULA
        var rotula = new Konva.Circle({
          x: largo - 35,
          y: 285,
          radius: 7.5,
          fill: 'red',
          stroke: 'black',
          strokeWidth: 2,
        });

        rotula.on('pointerdown', function () {
          counter[4] = counter[4] + 1
          newRotula(blockSnapSize * 17, blockSnapSize * 3, layer, stage, counter[4]);
        });
        var rotulaText = new Konva.Text({
          x: largo - 50,
          y: 305,
          text: 'Rotula',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(rotulaText);
        // ROTULA
        // BIELA
        var biela = new Konva.Circle({
          x: largo - 35,
          y: 345,
          radius: 7.5,
          fill: 'green',
          stroke: 'black',
          strokeWidth: 2,
        });

        biela.on('pointerdown', function () {
          counter[5] = counter[5] + 1
          newBiela(blockSnapSize * 17, blockSnapSize * 3, blockSnapSize * 17+30, blockSnapSize * 3,  layer, stage, counter[5]);
        });
        var bielaText = new Konva.Text({
          x: largo - 50,
          y: 365,
          text: 'Biela',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(bielaText);
        // BIELA

        //MOMENTO
        let momento = new Konva.Arc({
          x: largo - 37.5,
          y: 400,
          innerRadius: 10,
          outerRadius: 20,
          angle: 180,
          fill: 'yellow',
          stroke: 'black',
          strokeWidth: 4,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        momento.on('pointerdown', function () {
          counter[6] = counter[6] + 1
          
          newMomento(blockSnapSize * 17, blockSnapSize * 3, rotation = 0, layer, stage, counter[6]);
        });

        var momentoText = new Konva.Text({
          x: largo - 57,
          y: 425,
          text: 'momento',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(momentoText);
        //MOMENTO

        //BARRA
        let barra = new Konva.Rect({
          x: largo -50,
          y: 450,
          width: 25,
          height: 25,
          
          fill: 'gray',
          stroke: 'black',
          strokeWidth: 3,
          shadowColor: 'black',
          shadowBlur: 2,
          shadowOffset: {x : 1, y : 1},
          shadowOpacity: 0.4,
          draggable: false,
        });
        barra.on('pointerdown', function () {
          newBarra(blockSnapSize * 17, blockSnapSize * 3, layer, stage);
        });

        var barraText = new Konva.Text({
          x: largo - 50,
          y: 480,
          text: 'barra',
          fontSize: 12,
          fontFamily: 'Calibri',
          fill: 'balck',
        });
        layer.add(barraText);
        //BARRA

        layer.add(arrow);
        layer.add(fijo);
        layer.add(deslizante);
        layer.add(empotrado);
        layer.add(rotula);
        layer.add(biela);
        layer.add(momento);
        layer.add(barra);

      }
      
      
      
        let drawingLine = false;
        let line;
        stage.on('mousedown', (e) => {
          if (e.target.hasName('node')) {
            drawingLine = true;
            const pos = stage.getPointerPosition();
            line = new Konva.Line({
              stroke: 'black',
              strokeWidth: 7,
              // remove line from hit graph, so we can check intersections
              listening: false,
              points: [e.target.x(), e.target.y(), pos.x, pos.y]
            });
            layer.add(line);
          }
        });
        
        stage.on('mouseover', (e) => {
          if (e.target.hasName('node')) {
            e.target.stroke('black');
            layer.draw();
          }
        });
        
        stage.on('mouseout', (e) => {
          if (e.target.hasName('node')) {
            e.target.stroke(null);
            layer.draw();
          }
        });
        
        stage.on('mousemove', (e) => {
          if (!line) {
            return;
          }
          const pos = stage.getPointerPosition();
          const points = line.points().slice();
          points[2] = pos.x;
          points[3] = pos.y;
          line.points(points);
          layer.batchDraw();
        });
        
        stage.on('mouseup', (e) => {
          if (!line) {
            return;
          }
          if (!e.target.hasName('node')) {
            line.destroy();
            layer.draw();
            line = null;
          } else {
            let pos = e.target.getClientRect();
            const points = line.points().slice();
            points[2] = pos.x + (e.target.width()/2);
            points[3] = pos.y + (e.target.height()/2);;
            line.points(points);
            layer.batchDraw();
            line = null;
          }
          
        });

        shadowRectangle.hide();
        layer.add(shadowRectangle);

        //counter[ARROW, FIJO, DESLIZANTE, EMPOTRADO, ROTULA, BIELA, MOMENTO]
        counter = [0, 0, 0, 0, 0, 0, 0]
        
        toolBar(layer, stage, counter);
        loadForm(data);
        
        stage.add(layer);
        layer.draw();
    </script>
    <div>
        <input id="save_btn" type="button" style="float: left;" value = "Guardar"/>
        <input id="next_btn" type="button" style="float: right;" onclick="location.href='{% url 'edit_forces' homework_id=homework.id %}'" value = "Siguiente etapa"/>
        
      <script> 
      $(document).ready(function () {
			
			let homework_id = $("#homework-details").data("homeworkId")
			let btn2 = document.getElementById("save_btn");
			btn2.addEventListener('click', event => {

        let json = stage.toJSON();
				$.ajax({
					url: `/homework/${homework_id}/`,
              		type: "POST",
              		data:{
                		"diagram": json,
                		"id": homework_id,
						        csrfmiddlewaretoken: "{{ csrf_token }}"
              		},
              		success: function (data) {
						        console.log("guardo")
                		console.log(JSON.parse(json)["children"][0]["children"]);
              		},
              		error: function (error) {
                		console.log("guardaon't")
              		}
            	});
          	})
        });
        </script>
    </div>
  </body>
</html>